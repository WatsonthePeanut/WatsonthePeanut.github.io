<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Data Structure | 夢よ未来へ</title><meta name="author" content="WatsonthePeanut"><meta name="copyright" content="WatsonthePeanut"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="基于 CS 61B Spring 2024 的数据结构笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structure">
<meta property="og:url" content="http://example.com/2025/05/22/Data-Structure/index.html">
<meta property="og:site_name" content="夢よ未来へ">
<meta property="og:description" content="基于 CS 61B Spring 2024 的数据结构笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/dataStructurePost/0.png">
<meta property="article:published_time" content="2025-05-22T02:41:50.000Z">
<meta property="article:modified_time" content="2025-08-15T06:13:02.594Z">
<meta property="article:author" content="WatsonthePeanut">
<meta property="article:tag" content="Data Structure">
<meta property="article:tag" content="CS61B">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/dataStructurePost/0.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Data Structure",
  "url": "http://example.com/2025/05/22/Data-Structure/",
  "image": "http://example.com/img/dataStructurePost/0.png",
  "datePublished": "2025-05-22T02:41:50.000Z",
  "dateModified": "2025-08-15T06:13:02.594Z",
  "author": [
    {
      "@type": "Person",
      "name": "WatsonthePeanut",
      "url": "https://github.com/WatsonthePeanut"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2025/05/22/Data-Structure/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: WatsonthePeanut","link":"链接: ","source":"来源: 夢よ未来へ","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Data Structure',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> Miku</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-circle-info"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/dataStructurePost/0.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">夢よ未来へ</span></a><a class="nav-page-title" href="/"><span class="site-name">Data Structure</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> Miku</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-circle-info"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Data Structure</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-05-22T02:41:50.000Z" title="发表于 2025-05-22 10:41:50">2025-05-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>开学第一课</h1>
<h2 id="前言">前言</h2>
<p>CS61B 毫无疑问是一门经典好课，但这篇博客是依托又臭又长的构式。它仅作为本人学习时用于备忘的笔记，分类极其混乱，也没有任何勘误，不建议任何人当作参考。</p>
<p><s>但如果有人仍坚持要看的话，由于篇幅原因，这篇文章大概只会介绍课程中的 Java 基础，具体的数据结构内容请点击链接跳转。</s></p>
<p><s>当然也非常欢迎品鉴了这坨的大佬们在评论区批评指正。</s></p>
<h2 id="我们的第一个-Java-程序">我们的第一个 Java 程序</h2>
<h3 id="Hello-World">Hello World</h3>
<ul>
<li>在 Java 中，所有代码必须是类的一部分；</li>
<li>类使用 <code>public class CLASSNAME</code> 来定义；</li>
<li>使用大括号{}描述开始与结束；</li>
<li>使用分号作为一行的结尾；</li>
<li>我们想要运行的代码必须在 <code>public static void main(String[] args)</code> 中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hello-Numbers">Hello Numbers</h3>
<ul>
<li>Java 变量在使用前必须先声明；</li>
<li>Java 变量必须有特定类型；</li>
<li>Java 变量的类型永远无法改变；</li>
<li>在代码运行前，类型会先被验证。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">            x = x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Larger">Larger</h3>
<ul>
<li>Java 中，函数必须被作为类的一部分声明。函数作为类的一部分被称作“方法”，所以 Java 中，所有的函数都是方法；</li>
<li>Java 中我们使用 <code>public static</code> 定义函数，更多方式将在后面见到；</li>
<li>函数的所有参数必须被声明类型，函数的返回值也必须被声明类型。Java 中的函数只能返回一个值！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">larger</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(larger(-<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="补充一下：">补充一下：</h3>
<p>在 Java 中，编译和解释是两个独立的步骤。<br>
<img src="/img/dataStructurePost/1.1.jpg" alt="编译与解释"><br>
<code>.class</code> 文件可以轻松反编译为高度相似的 Java 源代码。</p>
<p>Statically Typed Language（静态类型语言）是一种编程语言的类型系统特性，指在编译阶段（而非运行时）就确定变量、方法参数和返回值的类型，并在编译时进行类型检查。Java 是一种静态类型语言。</p>
<h2 id="Object-Oriented-Programming">Object-Oriented Programming</h2>
<p><s>学一门语言永远逃不掉的面向对象</s></p>
<ul>
<li>一种组织程序的模型
<ul>
<li>模块化：可以单独实现程序的一部分而不需要担心其他部分。</li>
<li>数据抽象：不需要知道对象内部的具体实现也可以调用该对象。<s>就像蓝桥杯上不会写排序，也可以直接调用.sort()</s></li>
</ul>
</li>
<li>类与对象
<ul>
<li>类是对象的模板，对象是类的具体实现。<s>就像小狗有很多品种，但它们都是狗</s></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    String model;                   <span class="comment">// 实例变量（instance variables, 区分于静态变量 static variables）</span></span><br><span class="line">    <span class="type">int</span> wheels;                     <span class="comment">// 必须在类中显示声明实例变量，之后才能在构造方法中使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String m)</span> &#123;          <span class="comment">// 构造器（Constructor）是一种特殊的方法</span></span><br><span class="line">                                    <span class="comment">// 用于创建类的新对象</span></span><br><span class="line">                                    <span class="comment">// 构造器的方法名必须与类名一致</span></span><br><span class="line">                                    <span class="comment">// 可以接受参数</span></span><br><span class="line">                                    <span class="comment">// 通过构造器为对象的成员变量（局部状态 local state）赋初值</span></span><br><span class="line">        <span class="built_in">this</span>.model = m;             <span class="comment">// this关键字</span></span><br><span class="line">                                    <span class="comment">// 只能在方法内部使用</span></span><br><span class="line">        <span class="built_in">this</span>.wheels = <span class="number">4</span>;            <span class="comment">// 表示对“调用方法的那个对象”的引用</span></span><br><span class="line">                                <span class="comment">// 只在必要时使用，如：变量名重复或需要返回对当前对象的引用（return this）时</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.wheels &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.model + <span class="string">&quot; no go vroom&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.model + <span class="string">&quot; go vroom&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumWheels</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.wheels;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driveIntoDitch</span><span class="params">(<span class="type">int</span> wheelsLost)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wheels = <span class="built_in">this</span>.getNumWheels() - wheelsLost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Car c1;</span><br><span class="line">        Car c2;</span><br><span class="line">        c1 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Civic Type R&quot;</span>);   <span class="comment">// 实例化（Instantiation）：使用 new 关键字创建一个对象</span></span><br><span class="line">        c2 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Toyota Camry&quot;</span>);</span><br><span class="line">        c1.drive();</span><br><span class="line">        System.out.println(c1.getNumWheels());</span><br><span class="line">        c1.driveIntoDitch(<span class="number">2</span>);</span><br><span class="line">        c1.drive();</span><br><span class="line">        System.out.println(c1.getNumWheels());</span><br><span class="line">        System.out.println(c2.getNumWheels());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>Java 中的类</h1>
<h3 id="类的定义与实例化">类的定义与实例化</h3>
<p>如上一节所说：</p>
<ul>
<li>所有代码必须在一个类中；</li>
<li>为了运行一个类，我们必须定义一个主方法。
<ul>
<li>并非所有类都有一个主方法！</li>
</ul>
</li>
</ul>
<p>狗狗们都是怎么叫的？或许我们可以用一个类统一地表述：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bark!&quot;</span>);    <span class="comment">// 不能直接运行因为没有主方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Dog.makeNoise();                <span class="comment">// 调用一个来自另一个类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然而，并非所有狗都是“barkbark”地叫。但若是为每种叫法都创建一个类，未免显得有些愚笨······我们能不能利用这个类做点事情？</p>
<p>通常地，一只狗发出的声音取决于它的重量，于是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weightInPounds;                      <span class="comment">// 实例变量 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> w)</span> &#123;                             <span class="comment">// 构造器</span></span><br><span class="line">        weightInPounds = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeNoise</span><span class="params">()</span> &#123;                       <span class="comment">// 实例方法（区别于静态方法）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.weightInPounds &lt; <span class="number">10</span>) &#123;             <span class="comment">// 如果一个方法将被该类的实例调用</span></span><br><span class="line">            System.out.println(<span class="string">&quot;yipyipyip!&quot;</span>);       <span class="comment">// 则该方法应该是非静态的</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.weightInPounds &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bark!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arooooooo!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);                   <span class="comment">// 声明（Declaration）、实例化（Instantiation）与赋值（Assignment）</span></span><br><span class="line">        myDog.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="静态成员-vs-实例成员">静态成员 vs. 实例成员</h3>
<p>看到这之前，你也许会想：他妈的，老是讲“实例”“静态”的，到底啥意思？我也是这么想的。</p>
<p>当我们的变量或方法是静态（static）的时候，这个变量或方法是通用的，适用于所有狗而不是任何特定的狗，比如：狗都是如何发出声音的？而非静态的（non-static,又名实例，instance）变量或方法是针对一个特定狗的，比如：小狗Maya是如何发出声音的？</p>
<ul>
<li>静态方法（变量）使用类名调用，如：<code>Dog.makeNoise()</code>；</li>
<li>实例方法（变量）使用实例名（对象）调用，如：<code>maya.makeNoise()</code>；</li>
<li>静态方法无法访问实例变量，也无法调用实例方法，但反过来是可以的。
<ul>
<li>静态方法只与类有关，与实例化的对象无关。静态方法甚至不需要创建对象就可以直接调用，如：<code>x = Math.round(5,6);</code> 要比</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Math</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Math</span>();</span><br><span class="line">x = m.round(<span class="number">5.6</span>);</span><br></pre></td></tr></table></figure>
<p>方便太多了。</p>
<ul>
<li>如果传递一个对象的引用到静态方法，这样可以访问和调用该对象的实例变量与实例方法，如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d1, Dog d2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (d1.weightInPounds &gt; d2.weightInPounds) &#123;</span><br><span class="line">        <span class="keyword">return</span> d1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>应当始终通过类名访问静态变量，而非实例名。强烈建议避免使用值可变的静态变量。</li>
</ul>
<h1>Java 中的类型</h1>
<p>为了引入这节的内容，我们将从一个海象谜团开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们现在有一个海象类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Walrus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> tuskSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Walrus</span><span class="params">(<span class="type">int</span> w, <span class="type">double</span> ts)</span> &#123;</span><br><span class="line">        weight = w;</span><br><span class="line">        tuskSize = ts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/dataStructurePost/3.1.jpg" alt="海象谜团"><br>
左侧程序中，对海象 b 的修改会影响海象 a 的体重吗？右侧程序中，对 x 的修改又会影响 y 的值吗？</p>
<p>考虑好答案了吗？</p>
<p>在揭晓答案之前，我们不得不介绍一些你在计算机科学职业生涯中可能会一直使用的东西。</p>
<h2 id="基本类型（Primitive-Types）">基本类型（Primitive Types）</h2>
<h3 id="Bits">Bits</h3>
<p>深入电脑的最底层，你将发现一堆“0”和“1”</p>
<ul>
<li>我们看到的数据必须被编码为一系列的“0”和“1”以便存储在内存中，例如：
<ul>
<li>72 被存储为 01001000；</li>
<li>205.75 被存储为 0 10000110 10011011100000000000000；</li>
<li>字母 <code>H</code> 被存储为 01001000（与数字72相同）；</li>
<li><code>True</code> 被存储为 00000001。</li>
</ul>
</li>
<li>在 Java 中每个变量都有关联的类型，每种类型都有不同的方式来解释这些二进制位
<ul>
<li>Java 中的8种基本类型（Primitive Types）：<code>byte</code>、<code>short</code>、<strong>int</strong>、<code>long</code>、<code>float</code>、<strong>double</strong>、<code>boolean</code>、<code>char</code></li>
<li>在 61C 中会解释更多细节</li>
</ul>
</li>
</ul>
<h3 id="声明变量">声明变量</h3>
<p>在 Java 中声明特定类型的变量时：</p>
<ul>
<li>你的计算机会分配刚好足够的二进制位来存储该类型的值，例如：
<ul>
<li>声明一个 <code>int</code> 会分配一个 32 位的“盒子”；</li>
<li>声明一个 <code>double</code> 会分配一个 64 位的“盒子”。</li>
</ul>
</li>
<li>Java 会创建一个内部映射表，将每个变量名关联到一个内存位置；</li>
<li>Java 不会在这些预留的盒子中写入任何内容。
<ul>
<li><strong>出于安全考虑，Java 不允许你访问未初始化的变量！</strong></li>
</ul>
</li>
</ul>
<h3 id="等号的黄金法则（The-Golden-Rule-of-Equals）">等号的黄金法则（The Golden Rule of Equals）</h3>
<p>等号的黄金法则：<br>
<strong>“赋值操作（=）将右侧的值（或表达式结果）写入左侧的变量所代表的内存位置。”</strong></p>
<p>也就是说如果你有一个 <code>y = x</code> 语句，等号所做的一切就是将 x 的值复制出一份副本放在 y 中，最终我们会得到：<br>
<img src="/img/dataStructurePost/3.2.jpg" alt="简化盒子表示法"><br>
所以 <code>x = 2;</code> 只会对 x 对应内存位置的内容进行修改，并不会影响 y 中的副本。</p>
<h2 id="引用类型（Reference-Types）">引用类型（Reference Types）</h2>
<p>看来我们得到了第二个问题的答案，但为了解开海象谜团，我们还不得不搞清楚 <code>Walrus a = new Walrus(1000, 10.8);</code> 究竟做了什么事。</p>
<p>很明显，上面提到的 8 种基本类型并不包括我们的 Walrus。除了基本类型，其他任何类型都是引用类型。</p>
<h3 id="类的实例化（等号右边）">类的实例化（等号右边）</h3>
<p><strong>当我们实例化一个对象时，实际上是创建了对该对象的引用。</strong></p>
<p>什么意思呢？对于 <code>new Walrus(1000, 8.3);</code>：</p>
<ul>
<li>Java 首先会遍历整个内存，找到一块合适的位置为类的每个实例变量分配一个二进制的盒子，并用默认值填充（例如 0、false 或 null）；</li>
<li>构造器随后会将这些存储盒中的值替换为指定的初始值；</li>
<li>就像埋下了个宝藏，我们得知道它的位置，所以要进行 new 操作：它返回的是这块新创建内存地址。
<ul>
<li>在 Java 中，内存地址是 64 位的。</li>
<li>例如：如果对象被创建在内存位置 2384723423，那么 new 就会返回 2384723423。</li>
</ul>
</li>
</ul>
<p><img src="/img/dataStructurePost/3.3.jpg" alt=""><br>
我们现在知道了海象的位置，接着我们得把它记下来！</p>
<h3 id="引用类型变量的声明（等号左边）">引用类型变量的声明（等号左边）</h3>
<p>当我们声明一个任意引用类型的变量，如 <code>Walrus someWalrus;</code> 时：</p>
<ul>
<li>Java 会分配一个 64 位大小的盒子</li>
<li>盒子中的位可以被设置为：
<ul>
<li>Null（全为 0）</li>
<li>某个类的实例的 64 位地址（由 <code>new</code> 返回）</li>
</ul>
</li>
</ul>
<p><img src="/img/dataStructurePost/3.4.jpg" alt="我们使用箭头来象征地址"></p>
<p>究其本质，<strong>引用类型的变量存储的并不是该对象的实体，而是对该对象的引用（也就是地址）。</strong></p>
<h3 id="引用类型同样遵循等号黄金法则">引用类型同样遵循等号黄金法则</h3>
<p>搞清楚了上面的内容，<code>b = a</code> 的操作本质上也只是将 <code>Walrus a</code> 对 <code>Walrus(1000, 8.3)</code> 实体的引用复制出一份副本给了 <code>Walrus b</code>。<br>
<img src="/img/dataStructurePost/3.5.jpg" alt=""><br>
<code>Walrus a</code> 与 <code>Walrus b</code> 指向的都是同一个实体，那么通过 <code>Walrus b</code> 修改 <code>Walrus</code> 实体自然会影响通过 <code>Walrus a</code> 访问 <code>Walrus</code> 实体的结果。我想我们解开了海象谜团。</p>
<h2 id="参数传递">参数传递</h2>
<p>当你在尝试将变量作为参数传递给方法的时候，虽然你并没有在 <code>x</code> 与 <code>a</code> 之间看到什么等号，但等号的黄金法则仍然奏效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5.5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10.5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> average(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>伴随着方法的调用，<code>x</code> 与 <code>y</code> 被分别复制出一份副本到 <code>a</code> 和 <code>b</code> 中，这便是值传递（Pass by Value）。其中 <code>a</code> 与 <code>b</code> 是形参（parameter），<code>x</code> 与 <code>y</code> 是实参（argument）。</p>
<p>而对于对象类型的参数，Java采用的是引用副本传递（Pass by Copy of Reference）：</p>
<ul>
<li>方法接收的是引用的副本（即内存地址的拷贝）；</li>
<li>可以通过这个引用修改对象的内容；</li>
<li>但对参数重新赋值不会影响原始引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    </span><br><span class="line">    MyObject(<span class="type">int</span> v) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">modifyObject</span><span class="params">(MyObject obj)</span> &#123;</span><br><span class="line">    obj.value = <span class="number">20</span>;         <span class="comment">// 修改①：影响原始对象</span></span><br><span class="line">    obj = <span class="keyword">new</span> <span class="title class_">MyObject</span>(<span class="number">30</span>); <span class="comment">// 修改②：不影响外部引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>(<span class="number">10</span>);</span><br><span class="line">    modifyObject(myObj);</span><br><span class="line">    System.out.println(myObj.value); <span class="comment">// 输出什么？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>真正的引用传递（Pass by Reference）如 C++ 的引用参数（&amp;），允许方法内对参数的修改（包括重新赋值）直接影响原始变量。</p>
<h2 id="数组">数组</h2>
<p>我们再来简单了解一下数组：<br>
数组并不是基本类型，所以想要创建一个数组时，也要使用 <code>new</code> 关键字，并像其他对象一样将数组实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Planet</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Planet</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;blah.png&quot;</span>);</span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">95</span>, <span class="number">4</span>&#125;; <span class="comment">// 声明、赋值、实例化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/dataStructurePost/3.6.png" alt="声明、赋值、实例化"><br>
对于字符串数组，数组中将不会存储每个字符串而是每个字符串的地址，因为字符串不是基本类型。</p>
<h1>列表（Lists）</h1>
<p>不同于 C++ 中的 vector，在 Java 中，数组有固定的大小。当我声明有一个大小为 5 的新数组时，它的大小将永远是 5，不能添加更多的元素。</p>
<p>那么如果我想要一个大小可以随着我添加的数据增加而变大的这种数据结构呢？</p>
<p>所以让我们开始构建 Lists 的旅程吧。</p>
<p><a href="/2025/06/05/Lists"> <em><strong>列表（Lists）</strong></em> </a></p>
<h1>数组（Arrays）</h1>
<p>我们花了一些时间完成了我们的链表的构建，但这只是一种为我们的用户提供列表的方法。所以从现在开始，我们要从头开始建立一个全新的列表类型，但这次我们将使用半径作为底层数据结构而不是节点和链接。</p>
<p><a href="/2025/06/05/Arrays"> <em><strong>数组（Arrays）</strong></em> </a></p>
<h1>继承（Inheritance）</h1>
<h2 id="接口继承（Interface-Inheritance）">接口继承（Interface Inheritance）</h2>
<p>目前我们已经实现了我们的 <code>SLList</code> 和 <code>AList</code>！而当用户使用时通常会将他们使用的数据结构作为参数传递到方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: WordUtils.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 假设我们要实现一个方法从 List 中取得最长的单词</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(SLList&lt;String&gt; List)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> maxDex; i &lt; List.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (List.get(i).length() &gt; List.get(maxDex).length()) &#123;</span><br><span class="line">                maxDex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> List.get(maxDex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SLList&lt;String&gt; List = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;&gt;();</span><br><span class="line">        List.addLast(<span class="string">&quot;elk&quot;</span>);</span><br><span class="line">        List.addLast(<span class="string">&quot;are&quot;</span>);</span><br><span class="line">        List.addLast(<span class="string">&quot;watching&quot;</span>);</span><br><span class="line">        System.out.println(longest(List));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/dataStructurePost/6.1.png" alt="结果"><br>
但用户肯定不总是想用 <code>SLList</code> 来实现这个操作，如果我们换成是 <code>AList</code>，编译器又不高兴了：<br>
<img src="/img/dataStructurePost/6.2.png" alt=""><br>
这个问题该如何解决？再复制一个 <code>longest</code> 方法并将参数换成 <code>AList</code> 就好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: WordUtils.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(AList&lt;String&gt; list)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(SLList&lt;String&gt; list)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法名相同但参数不同，称为方法的 <strong>重载（Overload）</strong> 。<br>
虽然重载能解决目前的问题，这并不是一个好主意，因为：</p>
<ul>
<li>相同的代码重复了两次，看起来有点恶心；</li>
<li>如果以后又创建了 <code>DList</code>、<code>QList</code>，又不得不复制出第 3 个、第 4 个方法；</li>
<li>难以维护：如果在被重载的方法中发现了 bug，其它的方法也同样需要修复。</li>
</ul>
<p>还有什么解决方法呢？</p>
<h3 id="实现抽象方法">实现抽象方法</h3>
<h4 id="上位词（Hypernym）与下位词（Hyponym）">上位词（Hypernym）与下位词（Hyponym）</h4>
<p>给贵宾犬和给阿拉斯加洗澡的步骤都是一样的：梳好毛、放好热水、打好香皂、冲干净、吹干······所以我们可以用一个上位词“狗”来代替各种狗的品种。</p>
<p>那我们可以把同样的思路应用在 Java 上吗？</p>
<h4 id="接口（Interface）与实现（Implements）">接口（Interface）与实现（Implements）</h4>
<p>因为<code>SLList</code> 与 <code>AList</code> 都具有相同的用户交互方法，所以 <code>SLList</code> 与 <code>AList</code> 都是 <code>List61B</code> 的一种，<code>List61B</code> 便是 <code>SLList</code> 和 <code>AList</code> 的上位词。<br>
<img src="/img/dataStructurePost/6.3.jpg" alt=""><br>
明确了这点后，对于上位词，我们不用关键词 <code>class</code> 而是改用 <code>interface</code> 来定义。</p>
<ul>
<li>接口内包含了一系列没有方法体的 <strong>抽象方法</strong> ，指定了 List61B 能做什么，而不是具体去实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: List61B.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(T item)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(T item)</span>;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeFirst</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们要用关键词 <code>implements</code> 告诉 Java 编译器 <code>SLList</code> 和 <code>AList</code> 是 <code>List61B</code> 的下位词（子类）。</p>
<ul>
<li>子类须要对接口内的抽象方法进行具体实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: AList.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;T&gt; &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(T x)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: SLList.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;T&gt; &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(T x)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面就可以直接在要实现的方法中直接使用接口了：<br>
<img src="/img/dataStructurePost/6.4.png" alt="File: WordUtils.java"></p>
<h4 id="重写（Override）与重载（Overload）">重写（Override）与重载（Overload）</h4>
<ul>
<li>子类重新定义父类中已有的方法且方法签名完全一致称为 <strong>重写</strong> ；</li>
<li>同一个类中方法名相同但参数不同称为 <strong>重载</strong> 。</li>
</ul>
<p><img src="/img/dataStructurePost/6.5.jpg" alt=""></p>
<p>用 <strong>@Override</strong> 注释可以显示标记重写方法，提高可读性。</p>
<ul>
<li>即使不写 @Override 子类仍能够重写方法，@Override 只是一个对重写方法的标记；</li>
<li>使用 @Override 的主要原因是避免输入错误。如果写了 @Override 但方法并没有进行重写，编译将会出错。</li>
</ul>
<h4 id="接口继承">接口继承</h4>
<p>我们刚刚所做的一切便是接口继承（Interface Inheritance）：</p>
<ul>
<li>接口：所有方法签名的列表；</li>
<li>继承：子类“继承”接口；</li>
<li>接口指定子类实现的方法而不去实现；</li>
<li>子类必须重写所有方法，否则编译将会出错。</li>
</ul>
<p>思考题：下面的代码能够编译吗？如果能，它运行时将发生什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   List61B&lt;String&gt; someList = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;String&gt;();</span><br><span class="line">   someList.addFirst(<span class="string">&quot;elk&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：When it runs, an SLList is created and its address is stored in the someList variable. Then the string “elk” is inserted into the SLList referred to by addFirst.</p>
<h3 id="继承-default-方法">继承 <code>default</code> 方法</h3>
<h4 id="直接继承-default-方法">直接继承 <code>default</code> 方法</h4>
<p>对于接口继承，除了实现抽象方法，Java 还允许继承 <code>default</code> 方法：子类不仅能继承方法签名，还有方法的具体实现。</p>
<p>使用关键字 <code>default</code> 来指定子类能够从接口继承的方法。</p>
<p>举个栗子：让我们再给 List61B.java 实现一个 <code>print()</code> 方法！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: List61B.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了保持整洁其他抽象方法已省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接利用接口中已有的抽象方法实现 print()</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); ++i) &#123;</span><br><span class="line">            System.out.print(get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样即使子类（如 <code>AList</code>）中并没有实现 <code>print()</code> 方法，也可以直接调用这个方法了：<br>
<img src="/img/dataStructurePost/6.6.png" alt=""><br>
但是现在又回到了我们曾经实现这些数据结构时遇到的问题：效率问题。这个接口提供的默认方法对所有子类来说都是高效的吗？<code>size()</code> 方法直接返回实例变量 <code>size</code>，很高效；<code>get()</code> 方法对 <code>AList</code> 来说直接返回数组下标对应的元素，很高效，但对 <code>SLList</code> 来说每次都要从头遍历一次链表，很慢所以要针对 <code>SLList</code> 进行改进。</p>
<h4 id="重写-default-方法">重写 <code>default</code> 方法</h4>
<p>如果你不喜欢一个接口中的 <code>default</code> 方法，你可以在其子类中对其进行重写，这样任何对该子类中该方法的调用都会直接调用重写的方法而不是 <code>default</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: SLList.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The boss doesn&#x27;t know what he&#x27;s doing!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">i</span> <span class="operator">=</span> sentinel.next; i != <span class="literal">null</span>; i = i.next) &#123;</span><br><span class="line">            System.out.print(i.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/dataStructurePost/6.7.png" alt=""></p>
<h4 id="Static-and-Dynamic-Type">Static and Dynamic Type</h4>
<p>是什么导致运行 <code>List.print()</code> 时调用的是 <code>SLList</code> 中的 <code>print()</code> 而不是 <code>List61B</code> 中的 <code>print()</code> 呢？这就不得不提到 Java 的两个类型：</p>
<p>compile-time type(static type):</p>
<ul>
<li>是变量在声明时的类型，在声明时被指定，且无法改变；</li>
<li>编译器在编译代码时使用的类型；</li>
<li>决定了哪些方法和属性可以被访问。</li>
</ul>
<p>run-time type(dynamic type):</p>
<ul>
<li>是变量在运行时实际指向的对象类型，在实例化时被指定（如 new），可以改变；</li>
<li>在程序运行期间确定的类型；</li>
<li>决定了实际调用哪个方法实现。</li>
</ul>
<p>如：<br>
<img src="/img/dataStructurePost/6.8.jpg" alt=""><br>
具体在下节中讨论。</p>
<h2 id="实现继承（Implementation-Inheritance）">实现继承（Implementation Inheritance）</h2>
<h3 id="extends-关键字"><code>extends</code> 关键字</h3>
<p>除了上面介绍的，我们除了可以对接口 <code>interface</code> 进行继承，还可以直接对类进行继承，这时我们就要用到关键词 <code>extends</code>。</p>
<h4 id="旋转单链表">旋转单链表</h4>
<p>举个例子：现在我想基于 <code>SLList</code> 再构建一个 <code>RotatingSLList</code>，使得能够将链表的最后一个元素移动到开头。</p>
<p>例如：我们链表中已经有了 [10, 11, 12, 13]，<br>
<code>rotateRight</code> 一次：[13, 10, 11, 12]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: RotatingSLList.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RotatingSLList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotateRight</span><span class="params">()</span> &#123;</span><br><span class="line">        addFirst(getLast());</span><br><span class="line">        removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        RotatingSLList&lt;Integer&gt; rsl = <span class="keyword">new</span> <span class="title class_">RotatingSLList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/* Creates SList: [10, 11, 12, 13] */</span></span><br><span class="line">        rsl.addLast(<span class="number">10</span>);</span><br><span class="line">        rsl.addLast(<span class="number">11</span>);</span><br><span class="line">        rsl.addLast(<span class="number">12</span>);</span><br><span class="line">        rsl.addLast(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Should be: [13, 10, 11, 12] */</span></span><br><span class="line">        rsl.rotateRight();</span><br><span class="line">        rsl.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>托福于 <code>extends</code> 关键字，我们得以从 <code>SLList</code> 继承所有的成员：</p>
<ul>
<li>所有实例与静态变量；</li>
<li>所有方法；</li>
<li>所有嵌套类。</li>
</ul>
<p><a href="/2025/05/22/Data-Structure/#%E6%9E%84%E9%80%A0%E5%99%A8">构造器没有被继承。</a></p>
<h4 id="复仇单链表">复仇单链表</h4>
<p>再举个例子：我们现在想再实现一个单链表，使得：</p>
<ul>
<li>能够记忆所有通过 <code>removeLast()</code> 删除的节点的值；</li>
<li>有一个额外的 <code>printLostItems()</code> 方法能够打印出所有已删除的节点的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: VengefulSLList.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VengefulSLList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        VengefulSLList&lt;Integer&gt; vs1 = <span class="keyword">new</span> <span class="title class_">VengefulSLList</span>&lt;&gt;();</span><br><span class="line">        vs1.addLast(<span class="number">1</span>);</span><br><span class="line">        vs1.addLast(<span class="number">5</span>);</span><br><span class="line">        vs1.addLast(<span class="number">10</span>);</span><br><span class="line">        vs1.addLast(<span class="number">13</span>);</span><br><span class="line">        <span class="comment">// vs1 is now: [1, 5, 10, 13]</span></span><br><span class="line"></span><br><span class="line">        vs1.removeLast();</span><br><span class="line">        vs1.removeLast();</span><br><span class="line">        <span class="comment">// After deletion, vs1 is: [1, 5]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should print out the numbers of the fallen, namely 10 and 13</span></span><br><span class="line">        System.out.print(<span class="string">&quot;The fallen are: &quot;</span>);</span><br><span class="line">        vs1.printLostItems();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先我们得有一个地方存储我们删掉的节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SLList&lt;T&gt; lostItems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">    lostItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;&gt;(); <span class="comment">// 别忘了实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着把这些节点打印出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLostItems</span><span class="params">()</span> &#123;</span><br><span class="line">    lostItems.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是还有一个问题，我们如何向这个 <code>lostItems</code> 中添加节点呢？既然 <code>lostItems</code> 中存储的是 <code>removeLast()</code> 删除的节点，那么 <code>removeLast()</code> 方法仅仅删除原链表的节点是不够的，还要向 <code>lostItems</code> 中添加删除的节点，因此我们要重写该方法。</p>
<p>但是如果我们尝试将 <code>SLList</code> 里的 <code>removeLast()</code> 方法复制过来，一些问题产生了：<br>
<img src="/img/dataStructurePost/6.8.png" alt=""><br>
<code>Node</code> 是 <code>private</code> 的、<code>sentinel</code> 是 <code>private</code> 的、<code>size</code> 也是 <code>private</code> 的······<code>private</code> 是如此私有以至于子类都无法访问。</p>
<p>这时候我们就要引入一个新的关键字 <code>super</code>，它是对父对象的引用。有了这个关键字，我们就可以直接使用 <code>SLList</code> 的 <code>removedLast()</code> 方法而不用把它复制过来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">x</span> <span class="operator">=</span> <span class="built_in">super</span>.removeLast();</span><br><span class="line">    lostItems.addLast(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造器">构造器</h4>
<p>回到我们之前提到的没有被继承的构造器。当我们调用子类的构造器时究竟发生了什么？我们不妨在调用子类的构造器处打一个断点然后 debug：<br>
<img src="/img/dataStructurePost/6.9.jpg" alt=""><br>
事实证明，所有构造器都必须首先调用父类的某个构造器。</p>
<ul>
<li>你可以用关键字 <code>super</code> 明确地调用构造器；</li>
<li>或者 Java 会自动为你这样做。</li>
</ul>
<p><img src="/img/dataStructurePost/6.10.jpg" alt=""></p>
<p>如果要调用带参数的构造器，就给 <code>super()</code> 传递一个参数。<br>
<img src="/img/dataStructurePost/6.11.jpg" alt=""></p>
<h3 id="实现继承">实现继承</h3>
<p>总结一下上面学到的内容：</p>
<p>Java的继承分为两大类：</p>
<ul>
<li>实现继承（类继承）：通过 <code>extends</code> 继承父类的具体实现（属性和方法）。</li>
<li>接口继承：通过 <code>implements</code> 实现接口的抽象方法或继承 <code>default</code> 方法。</li>
</ul>
<ol>
<li>实现继承</li>
</ol>
<ul>
<li>核心：子类复用父类的代码实现（包括字段和具体方法）。</li>
<li>用途：代码复用。</li>
<li>特点：
<ul>
<li>单继承（一个类只能继承一个父类）。</li>
<li>子类可以重写父类方法（@Override）。</li>
<li>父类的私有成员虽然会被继承，但无法直接访问。
<ul>
<li>在创建子类对象时，父类的构造器会被优先调用（显式或隐式），从而完成父类私有字段的初始化。</li>
<li>可通过父类提供的 public/protected 方法间接访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>接口继承</li>
</ol>
<ul>
<li>核心：子类实现接口的抽象方法或继承 <code>default</code> 方法。</li>
<li>用途：定义行为契约，规范行为。</li>
<li>特点：
<ul>
<li>多继承（一个类可实现多个接口）。</li>
<li>接口中的 <code>default</code> 方法提供默认实现，子类可选择重写。</li>
<li>接口无状态（不能有实例字段）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>字段（Field）：字段是类中定义的变量，用于存储对象的数据。它们是对象的“属性”或“成员变量”。<br>
状态（Status）：状态是对象在某一时刻的所有字段值的集合，表示对象的“当前状况”。</p>
</blockquote>
<h4 id="Object-类"><code>Object</code> 类</h4>
<p>事实上，Java 中你定义的每一个类，无论是 <code>Dog</code>，<code>IntList</code>，<code>SLList</code>，还是 <code>Walrus</code>，即使你没有说过 <code>extends Object</code>，都是 <code>Object</code> 类的子类。<br>
<img src="/img/dataStructurePost/6.12.jpg" alt=""><br>
所以所有类也都继承了 <code>Object</code> 的方法：<br>
<img src="/img/dataStructurePost/6.13.jpg" alt=""></p>
<h4 id="Is-A-vs-Has-A">Is-A vs. Has-A</h4>
<p><img src="/img/dataStructurePost/6.14.jpg" alt=""><br>
“继承”这一特性只应被用于处理“Is-A”关系而不是“Has-A”关系，例如 <code>SLList</code> <strong>Is-A</strong> <code>List61B</code>、<code>RotatingSLList</code> <strong>Is-A</strong> <code>SLList</code>······错误地使用“继承”将导致一系列麻烦。举个例子：</p>
<p>栈（Stack）是另一种美妙的数据结构，能够实现一些方法：</p>
<ul>
<li><code>push(x)</code>：将 <code>x</code> 放在栈顶；</li>
<li><code>pop()</code>：删除并返回栈顶元素。</li>
</ul>
<p>如果利用“栈有一个链表”的关系来实现栈：<br>
<img src="/img/dataStructurePost/6.15.jpg" alt=""><br>
一切都是如此简约和恰到好处。</p>
<p>但如果利用“栈是一个链表”这个关系来实现栈：<br>
<img src="/img/dataStructurePost/6.16.jpg" alt=""><br>
结果就是栈从链表那继承了一堆本不需要的方法。</p>
<h4 id="封装（Encapsulation）">封装（Encapsulation）</h4>
<p>当我们构建大型程序时，我们的敌人是复杂性。如果你必须要一次性记住所有的事情，那你将十分痛苦。为了有效地构建大型程序并成为一名优秀的程序员，学习如何管理复杂性是必要的。</p>
<p>封装的核心思想是：</p>
<blockquote>
<p>把数据（属性）和对数据的操作（方法）绑定在一起，并对外部隐藏实现细节，仅暴露必要的接口。</p>
</blockquote>
<p>简单来说，就像我们不需要知道一辆车是如何被造出来的，只要会开就好了，因此显著降低了开车的难度。</p>
<p>对程序而言也是如此：</p>
<ul>
<li>对内部而言，只需要提供外部需要的接口就好了。同时将字段设置为私有，外部也无法干扰内部的具体实现。</li>
<li>对外部而言，只需要使用对应的接口就好了，不需要关心内部的具体实现。</li>
</ul>
<p>而 Java 便是通过 <strong>访问控制符 + 方法访问</strong> 来实现封装的：</p>
<ol>
<li>使用 <code>private</code> 修饰成员变量<br>
将类中的成员变量设置为私有，外部无法直接访问。</li>
<li>提供 <code>public</code> 的 getter/setter 方法<br>
通过公共方法暴露对属性的受控访问接口。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; !name.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码中 <code>name</code> 便是私有属性，外部无法直接访问；<code>getName()</code> 便是 getter 方法，对属性值进行获取；<code>setName(String name)</code> 便是 setter 方法，对属性值进行设置。</p>
<h4 id="实现继承破坏了封装">实现继承破坏了封装</h4>
<p>但当封装遇到了实现继承可能会发生某些意料之外的问题。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">            bark();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        barkMany(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bark&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两段代码的功能完全一致，但当遇到了实现继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">            bark();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerboseDog</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;As a dog, I say: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">            bark();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VerboseDog</span> <span class="variable">vd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VerboseDog</span>();</span><br><span class="line">        vd.barkMany(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        barkMany(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;bark&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerboseDog</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">barkMany</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;As a dog, I say: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">            bark();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VerboseDog</span> <span class="variable">vd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VerboseDog</span>();</span><br><span class="line">        vd.barkMany(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要知道封装意味着外界用户永远无法得知 <code>Dog</code> 类的内部实现，只能通过接口与其进行交互；改变 <code>Dog</code> 的私有实现也不应该影响 <code>Dog</code> 类的外界用户。</p>
<p>但在运行主方法时，第一段代码能够正常输出，但第二段却陷入了在 <code>bark()</code> 和 <code>barkMany()</code> 之间反复横跳的无限循环中。</p>
<h3 id="类型检查与转换">类型检查与转换</h3>
<p>还记得上节我们谈到的静态与动态两个类型吗？</p>
<p>Java 会基于静态类型进行类型检查，基于动态类型选择实际要调用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    VengefulSLList&lt;Integer&gt; vsl = <span class="keyword">new</span> <span class="title class_">VengefulSLList</span>&lt;Integer&gt;();</span><br><span class="line">    SLList&lt;Integer&gt; sl = vsl;</span><br><span class="line"></span><br><span class="line">    sl.addLast(<span class="number">50</span>);</span><br><span class="line">    sl.removeLast();</span><br><span class="line"></span><br><span class="line">    sl.printLostItems();    <span class="comment">// SLList 中没有该方法，编译出错</span></span><br><span class="line">    VengefulSLList&lt;Integer&gt; vsl2 = sl;  <span class="comment">// 即使 sl 的动态类型是 VengefulSLList，也无法被直接赋值给 vsl2，编译出错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要点说明：</p>
<ol>
<li>方法调用与类型检查</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sl.removeLast();</span><br></pre></td></tr></table></figure>
<p>编译器阶段：</p>
<ul>
<li>编译器看到 <code>sl</code> 的类型是 <code>SLList</code>，查找 <code>SLList</code> 类是否有 <code>removeLast()</code> 方法。</li>
<li>找到了，类型检查通过，所以允许调用。</li>
<li>此时编译器并不知道实际调用具体哪个类的 <code>removeLast()</code> 来实现（<code>SLList</code> 还是 <code>VengefulSLList</code>）。</li>
</ul>
<p>JVM 运行时：</p>
<ul>
<li>JVM 根据 <code>sl</code> 的运行时类型（<code>VengefulSLList</code>）走虚方法表*。</li>
<li>它在 <code>VengefulSLList</code> 的虚方法表中查找 <code>removeLast()</code> 的真实方法地址，并跳转执行它。</li>
<li>所以调用的是 <code>VengefulSLList</code> 的 <code>removeLast()</code> 方法，而不是 <code>SLList</code> 的。</li>
</ul>
<blockquote>
<p>*虚方法表（vtable）是一个数组结构，存放着该类所实现的“虚方法”的指针。也就是说，对于每一个类，JVM 会构建一张表，把所有实例方法（可被重写的方法）、重写父类的方法、从父类继承的方法的实际实现地址存在里面。</p>
</blockquote>
<ol start="2">
<li>向上转型（Upcasting）：将子类对象引用转换为父类类型引用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLList&lt;Integer&gt; sl = vsl;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个关系就像在说复仇单链表是单链表。</li>
<li>向上转型是安全的，因为子类对象继承了父类的所有成员，Java 会自动完成隐式转换。</li>
<li>转型后只能访问父类中定义的成员，但由于动态绑定*，执行的仍然是子类中重写的方法。</li>
</ul>
<blockquote>
<p>*动态绑定指的是在运行时决定调用哪个方法的行为，而不是在编译期间就确定。动态绑定是实现 Java 多态的核心机制。</p>
</blockquote>
<ol start="3">
<li>向下转型（Downcasting）：将父类类型引用转换回子类类型引用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VengefulSLList&lt;Integer&gt; vsl2 = sl;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个行为就像在说这个单链表是复仇单链表。</li>
<li>不安全，需要显式转换和类型检查，且父类类型引用必须指向目标子类，否则会抛出 <code>ClassCastException</code>。</li>
<li>通常要配合 <code>instanceof</code> 判断使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sl <span class="keyword">instanceof</span> VengefulSLList) &#123;</span><br><span class="line">    VengefulSLList&lt;Integer&gt; vsl2 = (VengefulSLList&lt;Integer&gt;) sl;</span><br><span class="line">    vsl2.printLostItems();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高阶函数">高阶函数</h3>
<p>高阶函数（Higher-Order Functions, HOFs）：将其他函数作为参数（或返回函数作为结果）的函数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tenX</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> * x</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_twice</span>(<span class="params">f, x</span>):</span><br><span class="line">    <span class="keyword">return</span> f(f(x))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(do_twice(tenX, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>而 Java 要想实现这个功能，对于旧版本（Java 7 及以前）需要 3 个类：一个接口类，用于提供调用的接口；一个实现类，实现接口的抽象方法；一个主类，里面有实际调用的方法，会接收一个接口和变量作为参数。（其实干脆不用接口也行）<br>
<img src="/img/dataStructurePost/6.17.jpg" alt=""><br>
但对于 Java 8 及以后的版本，可以直接持有对方法的引用而不需要通过接口间接调用方法了，但对此不会过多赘述。</p>
<h2 id="子类型多态（Subtype-Polymorphism）">子类型多态（Subtype Polymorphism）</h2>
<h3 id="子类型多态-vs-显式高阶函数">子类型多态 vs. 显式高阶函数</h3>
<p>前面我们讲的主要内容就是关于 <strong>子类型多态</strong> 。</p>
<ul>
<li>多态：为不同类型的实体提供一个统一的接口。</li>
<li>子类型多态：父类引用指向子类对象、运行时动态绑定。</li>
</ul>
<p>但并非所有语言都有子类型多态。它们不会通过动态绑定来调用函数，而是显式地传递函数以在高阶函数内使用。<br>
<img src="/img/dataStructurePost/6.18.jpg" alt=""></p>
<blockquote>
<p>Callback（回调函数）是一种编程模式，将一个函数 A 作为参数传递给另一个函数 B，并在函数 B 的特定条件满足时调用函数 A。它的核心思想是“由被调用方（函数 B）决定何时执行传入的函数”，而不是由调用方直接控制。</p>
</blockquote>
<h3 id="泛型的-Max-方法">泛型的 <code>Max</code> 方法</h3>
<p>接下来让我们构建一些东西来体会子类型多态的力量吧：</p>
<p>现在我们想写一个方法 <code>max()</code> 能够返回 <strong>任何类型</strong> 的数组中的最大值。</p>
<p>我们先来看看这个实现有什么问题：<br>
<img src="/img/dataStructurePost/6.19.jpg" alt=""></p>
<ul>
<li><code>max(Object[] items)</code>：之前我们讲过，任何类都是 <code>Object</code> 类的子类。因此，这样写任何我们想比较的对象都可以被作为参数传入 <code>max()</code> 方法中，没什么问题；</li>
<li><code>(Dog) Maximier.max(dogs);</code>：如果我们传入的对象是 <code>Dog</code> 类的，那么 <code>max()</code> 方法返回的也是 <code>Dog</code> 类，因此进行类型转换也没什么问题；</li>
<li><code>(items[i] &gt; items[maxDex])</code>：啊哈，问题在这：并不是所有的对象都可以直接用“&gt;”比较，至少要给出比较的依据呀？是根据 <code>Dog</code> 的 <code>size</code> 大小？<code>name</code> 首字母？甚至是“蓬松程度”？</li>
</ul>
<p><img src="/img/dataStructurePost/6.20.png" alt=""></p>
<p>对于这个问题，我们可以在 <code>Dog</code> 类中提前写好比较的方法：<br>
<img src="/img/dataStructurePost/6.21.jpg" alt=""><br>
但这样做就需要我们只要有一个存在比较需求的类，就要为其单独写一个比较的方法，违背了我们当初的意愿：设计一个能返回 <strong>任何类型</strong> 的数组中的最大值的方法。</p>
<h4 id="我们的-Comparable">我们的 <code>Comparable</code></h4>
<p>这时候我们就要创建一个接口来保证一个统一的比较方法：</p>
<ul>
<li>让 <code>Dog</code> 实现这个接口</li>
<li>以接口的形式写 <code>Maximizer</code> 类的 <code>max()</code> 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: OurComparable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns -1 if I am less than o.</span></span><br><span class="line"><span class="comment">     * Returns 0 if I am equal to o.</span></span><br><span class="line"><span class="comment">     * Returns 1 if I am greater than o.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: Dog.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;    <span class="comment">// Object 不能换成 Dog 因为方法签名必须一致</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; ((Dog) o).size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == ((Dog) o).size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; says: bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: Maximizer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Maximizer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OurComparable <span class="title function_">max</span><span class="params">(OurComparable[] items)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> items[i].compareTo(items[maxDex]);</span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="number">1</span>) &#123;</span><br><span class="line">                maxDex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> items[maxDex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Elyse&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Sture&quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Benjamin&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        Dog[] dogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[]&#123;d1, d2, d3&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">maxDog</span> <span class="operator">=</span> (Dog) Maximizer.max(dogs); <span class="comment">// 类型转换是必需的</span></span><br><span class="line">        maxDog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>问题确实解决了，但还有几个问题：</p>
<ol>
<li>Override 的 <code>compareTo()</code> 方法有点长有点屎；</li>
<li><code>Dog</code> 与 <code>Object</code> 之间的类型转换有点尴尬且存在隐患；</li>
<li>目前实现 <code>OurComparable</code> 接口的类只有 <code>Dog</code>，除非重写整个 Java 标准库让所有类都实现该接口，否则这个方法将不会特别通用；</li>
</ol>
<p>问题一：其实我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - ((Dog) o).size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样返回的就不是 +1 或 -1 而是整数或负数了。事实上，真正的 Java 程序员也在应用这个技巧。</p>
<p>对于问题二和问题三，事实上，Java 提供一个内置的 <code>Comparable&lt;T&gt;</code> 接口供我们使用，其中包含一个抽象方法 <code>public int compareTo(T o);</code>。</p>
<h4 id="Comparable"><code>Comparable</code></h4>
<p><img src="/img/dataStructurePost/6.22.jpg" alt=""><br>
我们的 <code>Dog</code> 类就变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog otherDog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - otherDog.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在足够通用的基础上也减少了一些不必要的类型转换。</p>
<p>记得将其它 <code>OurComparable</code> 也替换为 <code>Comparable</code>。</p>
<h4 id="Comparators"><code>Comparators</code></h4>
<p>值得注意的是上面我们实现的比较方法 <code>compareTo()</code> 需要被比较的对象自身来调用以完成与同类的其他对象的比较：<code>items[i].compareTo(items[maxDex]);</code>，这意味着 <code>compareTo()</code> 方法必须要在类内对 <code>Comparable</code> 接口进行重写实现。但在同一个类中对同一个方法签名只能重写一次，所以这种比较方法只能定义一种。这种排序方式被称为 <strong>自然排序（Natural Ordering）</strong>。自然排序通常会选择一种默认的方式进行排序，如比较狗的重量，而不是狗的名字。</p>
<p>但如果我们还想比较狗的名字该怎么办？没关系，此时我们还有 <code>Comparator</code>！</p>
<p><code>Comparator&lt;T&gt;</code> 是 Java 中用于比较两个对象的接口，包含一个抽象方法：<code>int compare(T o1, T o2);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: NameComparator.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Dog&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dog d1, Dog d2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d1.name.compareTo(d2.name);  <span class="comment">// 这里作弊一下下，利用一下 String 类中的 compareTo()</span></span><br><span class="line">        <span class="comment">// 记得将 Dog 中的 name 设为 public 或者写个 getter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: Maximizer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Maximizer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Oski&quot;</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Cerebus&quot;</span>, <span class="number">999999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">NameComparator</span> <span class="variable">nc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NameComparator</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> nc.compare(d4, d5);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxDog = d4;    <span class="comment">// d4 comes later in the alphabet</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxDog = d5;    <span class="comment">// d5 comes later in the alphabet</span></span><br><span class="line">        &#125;</span><br><span class="line">        maxDog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>事实证明这完全没问题：<br>
<img src="/img/dataStructurePost/6.23.png" alt=""><br>
不过在实际的 Java 程序中 <code>Comparator</code> 并不是这个样子。事实上：</p>
<ul>
<li><code>NameComparator</code> 事实上是 <code>Dog</code> 的一个从属功能，所以像 <code>LinkedList</code> 的 <code>Node</code> 一样，<code>NameComparator</code> 不会作为一个独立的类，而是作为 <code>Dog</code> 类的一部分——嵌套类而出现。</li>
<li><code>NameComparator</code> 不同于 <code>size</code> 和 <code>name</code>，不是某个小狗对象的属性而是整个 <code>Dog</code> 类的功能，所以应该被声明为 <code>static</code>。</li>
<li>外界并不关心 <code>NameComparator</code> 的内部实现，所以我们要将其封装起来，再对外开放一个接口方法。</li>
</ul>
<p>我们终于得到了我们的最终版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: Dog.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Dog&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dog d1, Dog d2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> d1.name.compareTo(d2.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Dog&gt; <span class="title function_">getNameComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NameComparator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于我们无法再直接访问 <code>NameComparator</code> 了，使用时需要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Dog&gt; nc = Dog.getNameComparator();</span><br></pre></td></tr></table></figure>
<p>有了 <code>Comparator</code>，我们就可以任意定制任何我们想要的排序规则了！</p>
<h2 id="迭代器（Iterators）">迭代器（Iterators）</h2>
<p>这一节我们的目的是构建一个被称作 <code>ArraySet</code> 的集合。</p>
<ul>
<li>集合中的元素没有顺序</li>
<li>集合中的元素不能重复</li>
</ul>
<p>起初，一个 <code>ArraySet</code> 需要包含如下方法：</p>
<ul>
<li><code>add(value)</code>：向 <code>ArraySet</code> 中添加一个当前不存在的元素；</li>
<li><code>contains(value)</code>：查看当前 <code>ArraySet</code> 是否存在该键；</li>
<li><code>size()</code>：返回当前元素数量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: ArraySet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (contains(item)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = item;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items[i] == item) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArraySet&lt;Integer&gt; S = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">        S.add(<span class="number">5</span>);</span><br><span class="line">        S.add(<span class="number">23</span>);</span><br><span class="line">        S.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check that contains works</span></span><br><span class="line">        System.out.println(S.contains(<span class="number">42</span>));</span><br><span class="line">        System.out.println(S.contains(<span class="number">50</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着我们就可以为我们的 <code>ArraySet</code> 添加一些花哨的功能了。</p>
<h3 id="Iteration">Iteration</h3>
<h4 id="The-Enhanced-For-Loop">The Enhanced For Loop</h4>
<p>首先我们先讲一点语法知识，你可能在某些地方看到过类似于这种语法并感到困惑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; javaset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">javaset.add(<span class="number">5</span>);</span><br><span class="line">javaset.add(<span class="number">23</span>);</span><br><span class="line">javaset.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : javaset) &#123;     <span class="comment">// WTF is this</span></span><br><span class="line">   System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我也是前面学算法的时候才见过这个东西。事实上，这段 <code>for</code> 循环相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; seer = javaset.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> seer.next();</span><br><span class="line">   System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像还是挺难懂的，我们再解释一下：</p>
<ul>
<li>第一行 <code>Iterator&lt;Integer&gt; seer = javaset.iterator();</code> 为我们创建了一个迭代器 <code>seer</code>，相当于一个指针，它指向 <code>javaset</code> 对象的第一个元素；</li>
<li><code>hasNext()</code> 会为我们检查当前指向的位置是否有值；</li>
<li><code>next()</code> 会返回当前指向位置的值，并将指针移到下一个位置。</li>
</ul>
<p>说白了 <code>iterator</code> 就是采蘑菇的小姑娘，<code>hasNext()</code> 会看看脚下有没有蘑菇，<code>next()</code> 会采下蘑菇再往前走一步。</p>
<p>那当我们想将这位小姑娘请到我们的 <code>ArraySet</code> 中呢？</p>
<h4 id="iterator-next-hasNext-for-ArraySet">iterator, next, hasNext for ArraySet</h4>
<p>事实上，与 <code>Comparator</code> 一样，Java 也为我们提供了 <code>Iterator</code> 接口，所以我们要做的与写 <code>Comparator</code> 一样：写一个私有类负责实现接口，用一个 getter 返回 <code>Iterator</code>，最后就可以在主方法中使用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: ArraySet.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 非静态内部类隐式持有对外部类实例的引用</span></span><br><span class="line">    <span class="comment">// 所以不需要显式传入一个 ArraySet 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ArraySetIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> pos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ArraySetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pos &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">returnItem</span> <span class="operator">=</span> items[pos];</span><br><span class="line">            pos += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> returnItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法多余吗？</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArraySet&lt;Integer&gt; S = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">        S.add(<span class="number">5</span>);</span><br><span class="line">        S.add(<span class="number">23</span>);</span><br><span class="line">        S.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; seer = S.iterator();</span><br><span class="line">        <span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> seer.next();</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是直接写在 <code>ArraySet</code> 类内的，当然你也可以单独写一个类，只需要为 <code>size</code> 和 <code>items</code> 额外写两个 getter 就好了。</p>
<h4 id="Iterable">Iterable</h4>
<p>我们成功地把小女孩请了进来，但是这只是个底层的实现逻辑，我们真正使用时更期望用上更简洁的 Enhanced For Loop。但直接生搬硬套是不行的：<br>
<img src="/img/dataStructurePost/6.24.png" alt=""><br>
虽然有了迭代器，Java 并不知道我们的 <code>ArraySet S</code> 是可以迭代的，所以我们得用什么咒语告诉它。事实上，与 <code>Comparable</code> 相同，Java 也为这些可迭代的类内置了统一的接口 <code>Iterable</code>：<br>
<img src="/img/dataStructurePost/6.25.png" alt=""><br>
我们只要实现并重写这个接口的方法就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 所以就算不考虑上节课提到的规范性，上面的 iterator() 方法也并非多余</span></span><br><span class="line">    <span class="comment">// 因为 iterator() 是实现 Iterable&lt;T&gt; 接口必须重写的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArraySet&lt;Integer&gt; S = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">        S.add(<span class="number">5</span>);</span><br><span class="line">        S.add(<span class="number">23</span>);</span><br><span class="line">        S.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Nice iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : S) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Object-Methods">Object Methods</h2>
<p>还记得我们之前提到所有类都是 <code>Object</code> 类的一部分吗？所以所有类都继承了 <code>Object</code> 的方法，接下来我们尝试利用几个方法为我们的 <code>ArraySet</code> 增加几个功能。</p>
<h3 id="toString">toString</h3>
<p>先思考一个问题：我们一直以来使用的 <code>System.out.println(Object x)</code> 方法是如何为我们打印出我们想要的东西的呢？</p>
<p>答案是<a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/io/PrintStream.java#L896"> pintln() </a>方法会调用<a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/f0ef2826d2116f4e0c0ed21f8d54fe9d0706504e/src/java.base/share/classes/java/lang/String.java#L2951"> String.valueOf() </a>方法，最终调用<a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/lang/Object.java#L245"> toString() </a>来将参数转换为要打印的字符串。</p>
<p>而我们如果直接打印我们的 <code>ArraySet</code>，结果并不会与我们预料中的一致，因为我们的 <code>ArraySet</code> 还没有实现 <code>toString()</code> 方法，用的是直接从<a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/lang/Object.java#L245"> Object </a>那继承来的。</p>
<p>所以现在让我们实现一下吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (T i : <span class="built_in">this</span>) &#123;</span><br><span class="line">        x += i.toString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArraySet&lt;Integer&gt; S = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">    S.add(<span class="number">5</span>);</span><br><span class="line">    S.add(<span class="number">23</span>);</span><br><span class="line">    S.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toString.</span></span><br><span class="line">    System.out.println(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到我们能够正常打印出 <code>ArraySet</code> 了，但是这种实现方法不太好，因为字符串是不可修改的常量。当你用 “<code>+</code>” 尝试将几个字符串加在一起时，你是实际上是在创建一个新的字符串，这意味着实际上是将需要合并的字符串都复制到一个新的字符串中。有点像我们实现 <code>ArrayList</code> 的 <code>resize</code> 时遇到的问题，当字符串很长的时候这样做很慢。</p>
<p>为了解决这个问题，我们引入一个新的对象 <code>StringBuilder</code>。当向字符串中添加字符串时调用 <code>append()</code> 方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    x.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (T i : <span class="built_in">this</span>) &#123;</span><br><span class="line">        x.append(i.toString());</span><br><span class="line">        x.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    x.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="vs-equals">== vs. equals</h3>
<p>谈到比较两个对象是否相同，我们第一个想到的就是 “<code>==</code>” 运算符。<code>==</code> 运算符会比较两边的比特位是否完全一致。现在我们想比较两个 <code>ArrayList</code> 是否一致，先用它试试看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArraySet&lt;Integer&gt; S = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">    S.add(<span class="number">5</span>);</span><br><span class="line">    S.add(<span class="number">23</span>);</span><br><span class="line">    S.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// equals.</span></span><br><span class="line">    ArraySet&lt;Integer&gt; S2 = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">    S2.add(<span class="number">5</span>);</span><br><span class="line">    S2.add(<span class="number">23</span>);</span><br><span class="line">    S2.add(<span class="number">42</span>);</span><br><span class="line">    System.out.println(S == S2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>显然，结果是 false。因为 <code>S</code> 和 <code>S2</code> 都是引用类型的变量。即使它们分别指向的内存位置存储的东西从某些方面来说是相同的，但它们指向的内存位置不同，结果就是不同的。</p>
<p>事实上，我们也从 <code>Object</code> 那继承来了用于比较的方法 <code>equals()</code>，但直接使用的结果与刚才没什么区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(S.equals(S2));</span><br></pre></td></tr></table></figure>
<p>因为<a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/lang/Object.java#L157"> equals() </a>默认也是用 <code>==</code> 实现的。</p>
<p>所以让我们重写一个 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;    <span class="comment">// 如果引用指向同一个对象能够节省我们的时间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> ArraySet) &#123;</span><br><span class="line">        ArraySet&lt;T&gt; otherArraySet = (ArraySet&lt;T&gt;) o;</span><br><span class="line">        <span class="keyword">if</span> (size != otherArraySet.size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (T i : <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!otherArraySet.contains(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前面我们简单提过，<code>instanceof</code> 关键字会检查 <code>o</code> 的动态类型是否是 <code>ArraySet</code>。</p>
<p>当然如果你是用的是 Java 16 或更高的版本，可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> ArraySet otherArraySet) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>来直接取代上面的强制类型转换。</p>
<p>现在运行，我想我们就能得到我们想要的答案了。</p>
<h1>渐近分析</h1>
<p>学完 CS 61B，我们希望能够实现从“programmer”到“engineer”的蜕变。</p>
<p>也就是说，不仅需要从编码方面，更要从代码的执行层面上考虑问题，如：你的程序执行要花费多长时间？你的程序需要消耗多少内存？</p>
<p>所以我们还需要一些渐近分析的能力。</p>
<p><a href="/2025/07/31/Asymptotics"> <em><strong>渐进分析</strong></em> </a></p>
<h1>并查集（Disjoint Set）</h1>
<p>前面铺垫做得差不多了，接下来我们终于可以着手解决一系列经典的数据结构的问题了。<br>
这一节，我们将针对“动态连通性”问题，推导“并查集”数据结构。我们将看到：</p>
<ul>
<li>数据结构设计如何从基础形态逐步演进为复杂实现；</li>
<li>底层抽象的选择会如何影响算法时间复杂度（使用严谨的大Θ符号表示）与代码复杂度。</li>
</ul>
<p><a href="/2025/07/29/Disjoint-Set"> <em><strong>并查集（Disjoint Set）</strong></em> </a></p>
<h1>集合与映射（Sets &amp; Maps）</h1>
<h2 id="抽象数据类型（Abstract-Data-Types）">抽象数据类型（Abstract Data Types）</h2>
<p>也许你对这个观点感到无比厌倦：我们在继承章节中强调过，接口指定了能做什么，而不是具体去实现。</p>
<p>而抽象数据类型的主旨也是如此：它强调数据的逻辑行为和操作，而非具体的实现细节。ADT 定义了数据的“是什么”（功能），而不关心“如何做”（具体实现）。</p>
<p>例如前面我们用 <code>AList</code> 和 <code>SLList</code> 两种方式实现了 <code>List61B</code>，用 <code>ArrayDeque</code> 和 <code>LinkedListDeque</code> 实现了 <code>Deque</code>，甚至用 <code>QuickFindDS</code>、<code>QuickUnionDS</code>、<code>WeightedQuickUnionDS</code> 和 <code>WQUwithPathCompression</code> 四种方式实现了 <code>DisjointSets</code>。其中的 <code>List61B</code>、<code>Deque</code>、<code>DisjointSets</code> 便是抽象数据类型。</p>
<p>除此之外，常见的 ADT 还有：栈（Stack）、集合（Set）、映射（Map）。栈前面我们简单提到过，栈底层也是通过数组或链表来实现入栈 <code>push(int x)</code> 和出栈 <code>int pop()</code> 操作，在这里我们也不过多赘述了。</p>
<p>接下来我们将着力于对集合和映射的实现。</p>
<h2 id="二叉搜索树（Binary-Search-Trees）">二叉搜索树（Binary Search Trees）</h2>
<p>不过在此之前，请先允许我们介绍一下计算机领域中最巧妙的想法之一：</p>
<p><a href="/2025/08/05/Trees/#%E6%8E%A8%E5%AF%BC"> <em><strong>二叉搜索树（Binary Search Trees）</strong></em> </a></p>
<h2 id="集合与映射">集合与映射</h2>
<p>人们往往沉溺于 BST 概念的美好中而忘记了引入 BST 的目的：构建一个无序的、不重复的项目集。<br>
<img src="/img/dataStructurePost/9.1.jpg" alt=""><br>
除了存储独立的元素，还可以存储键值对，此时集合就变成了映射。<br>
<img src="/img/dataStructurePost/9.2.jpg" alt=""><br>
对于映射，只能通过键来查找值，而不能通过值来查找键。例如如果不遍历所有节点，无法找到所有值为 1 的键。</p>
<p>值得一提的是，虽然集合是无序的，但 BST 是有序的，这并不冲突。因为用户不在乎顺序并不意味着我们不能利用某种顺序来加快我们的速度。</p>
<p>利用 BST 实现映射的部分请查看<a href="/2025/08/12/Lab-7-BSTMap"> <em><strong>Lab 7: BSTMap</strong></em> </a></p>
<h1>哈希表（Hash Tables）</h1>
<p>这节我们将讨论一个不同于以往的全新的数据结构——<a href="/2025/08/14/Hashing"> <em><strong>哈希表（Hash Tables）</strong></em> </a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/WatsonthePeanut">WatsonthePeanut</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/05/22/Data-Structure/">http://example.com/2025/05/22/Data-Structure/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">夢よ未来へ</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Data-Structure/">Data Structure</a><a class="post-meta__tags" href="/tags/CS61B/">CS61B</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/dataStructurePost/0.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" title="我的第一篇博客文章"><img class="cover" src="/img/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">我的第一篇博客文章</div></div><div class="info-2"><div class="info-item-1">也是我的人生回忆录</div></div></div></a><a class="pagination-related  no-desc" href="/2025/06/05/Lists/" title="列表（Lists）"><img class="cover" src="/img/ListsPost/0.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">列表（Lists）</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/06/05/Arrays/" title="数组（Arrays）"><img class="cover" src="/img/ArraysPost/0.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-05</div><div class="info-item-2">数组（Arrays）</div></div></div></a><a class="pagination-related" href="/2025/07/31/Asymptotics/" title="渐近分析"><img class="cover" src="/img/AsymptoticsPost/0.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-31</div><div class="info-item-2">渐近分析</div></div><div class="info-2"><div class="info-item-1">大概是一节数学课</div></div></div></a><a class="pagination-related no-desc" href="/2025/07/29/Disjoint-Set/" title="并查集（Disjoint Set）"><img class="cover" src="/img/DisjointSetPost/0.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-29</div><div class="info-item-2">并查集（Disjoint Set）</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">开学第一课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-Java-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">我们的第一个 Java 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-World"><span class="toc-number">1.2.1.</span> <span class="toc-text">Hello World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-Numbers"><span class="toc-number">1.2.2.</span> <span class="toc-text">Hello Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Larger"><span class="toc-number">1.2.3.</span> <span class="toc-text">Larger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E4%B8%80%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.2.4.</span> <span class="toc-text">补充一下：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-Oriented-Programming"><span class="toc-number">1.3.</span> <span class="toc-text">Object-Oriented Programming</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Java 中的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.0.1.</span> <span class="toc-text">类的定义与实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-vs-%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98"><span class="toc-number">2.0.2.</span> <span class="toc-text">静态成员 vs. 实例成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Java 中的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%88Primitive-Types%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">基本类型（Primitive Types）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bits"><span class="toc-number">3.1.1.</span> <span class="toc-text">Bits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">声明变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%8F%B7%E7%9A%84%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99%EF%BC%88The-Golden-Rule-of-Equals%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">等号的黄金法则（The Golden Rule of Equals）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88Reference-Types%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">引用类型（Reference Types）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%88%E7%AD%89%E5%8F%B7%E5%8F%B3%E8%BE%B9%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">类的实例化（等号右边）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%88%E7%AD%89%E5%8F%B7%E5%B7%A6%E8%BE%B9%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">引用类型变量的声明（等号左边）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%90%8C%E6%A0%B7%E9%81%B5%E5%BE%AA%E7%AD%89%E5%8F%B7%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99"><span class="toc-number">3.2.3.</span> <span class="toc-text">引用类型同样遵循等号黄金法则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.3.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">列表（Lists）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">数组（Arrays）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">继承（Inheritance）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%EF%BC%88Interface-Inheritance%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">接口继承（Interface Inheritance）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">实现抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BD%8D%E8%AF%8D%EF%BC%88Hypernym%EF%BC%89%E4%B8%8E%E4%B8%8B%E4%BD%8D%E8%AF%8D%EF%BC%88Hyponym%EF%BC%89"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">上位词（Hypernym）与下位词（Hyponym）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88Interface%EF%BC%89%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88Implements%EF%BC%89"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">接口（Interface）与实现（Implements）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E4%B8%8E%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">重写（Override）与重载（Overload）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">6.1.1.4.</span> <span class="toc-text">接口继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-default-%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">继承 default 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BF-default-%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">直接继承 default 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99-default-%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">重写 default 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Static-and-Dynamic-Type"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">Static and Dynamic Type</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%88Implementation-Inheritance%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">实现继承（Implementation Inheritance）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extends-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.2.1.</span> <span class="toc-text">extends 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">旋转单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%BB%87%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">复仇单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">6.2.2.</span> <span class="toc-text">实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-%E7%B1%BB"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">Object 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Is-A-vs-Has-A"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">Is-A vs. Has-A</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%EF%BC%88Encapsulation%EF%BC%89"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">封装（Encapsulation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%A0%B4%E5%9D%8F%E4%BA%86%E5%B0%81%E8%A3%85"><span class="toc-number">6.2.2.4.</span> <span class="toc-text">实现继承破坏了封装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.2.3.</span> <span class="toc-text">类型检查与转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.4.</span> <span class="toc-text">高阶函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%A4%9A%E6%80%81%EF%BC%88Subtype-Polymorphism%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">子类型多态（Subtype Polymorphism）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%A4%9A%E6%80%81-vs-%E6%98%BE%E5%BC%8F%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">子类型多态 vs. 显式高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84-Max-%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.2.</span> <span class="toc-text">泛型的 Max 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E7%9A%84-Comparable"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">我们的 Comparable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparable"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">Comparable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparators"><span class="toc-number">6.3.2.3.</span> <span class="toc-text">Comparators</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Iterators%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">迭代器（Iterators）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Iteration"><span class="toc-number">6.4.1.</span> <span class="toc-text">Iteration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Enhanced-For-Loop"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">The Enhanced For Loop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iterator-next-hasNext-for-ArraySet"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">iterator, next, hasNext for ArraySet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterable"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">Iterable</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-Methods"><span class="toc-number">6.5.</span> <span class="toc-text">Object Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#toString"><span class="toc-number">6.5.1.</span> <span class="toc-text">toString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vs-equals"><span class="toc-number">6.5.2.</span> <span class="toc-text">&#x3D;&#x3D; vs. equals</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">渐近分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">并查集（Disjoint Set）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">集合与映射（Sets &amp; Maps）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88Abstract-Data-Types%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">抽象数据类型（Abstract Data Types）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88Binary-Search-Trees%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">二叉搜索树（Binary Search Trees）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="toc-number">9.3.</span> <span class="toc-text">集合与映射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">哈希表（Hash Tables）</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/img/dataStructurePost/0.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By WatsonthePeanut</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div><div class="footer_custom_text">繋いでいこうね MY FUTURE。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'transparent' : 'transparent'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'WatsonthePeanut/Giscus-blogcmt',
      'data-repo-id': 'R_kgDOOzHPtQ',
      'data-category-id': 'DIC_kwDOOzHPtc4Cqyrs',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script id="canvas_nest" defer="defer" color="255,255,255" opacity="1" zIndex="-1" count="150" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>